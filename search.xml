<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android低版本(4.x)无法通过app_process启动java进程问题详解</title>
    <url>/2019/11/17/Android%E4%BD%8E%E7%89%88%E6%9C%AC-4-x-%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87app-process%E5%90%AF%E5%8A%A8java%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>最近遇到一个奇怪的事情，公司有一块业务需要在Android上通过启动一个普通的java进程，但是从后台统计数据上来看在Android4.x上进程无法启动所以找台Nexux4 4.2.2的手机来试果然会崩溃，崩溃日志如下</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D&#x2F;AndroidRuntime( 3877): &gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START com.android.internal.os.RuntimeInit &lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">D&#x2F;AndroidRuntime( 3877): CheckJNI is OFF</span><br><span class="line">D&#x2F;dalvikvm( 3877): Trying to load lib libjavacore.so 0x0</span><br><span class="line">D&#x2F;dalvikvm( 3877): Added shared lib libjavacore.so 0x0</span><br><span class="line">D&#x2F;dalvikvm( 3877): Trying to load lib libnativehelper.so 0x0</span><br><span class="line">D&#x2F;dalvikvm( 3877): Added shared lib libnativehelper.so 0x0</span><br><span class="line">D&#x2F;dalvikvm( 3877): No JNI_OnLoad found in libnativehelper.so 0x0, skipping init</span><br><span class="line">E&#x2F;dalvikvm( 3877): Dex cache directory isn&#39;t writable: &#x2F;data&#x2F;dalvik-cache</span><br><span class="line">I&#x2F;dalvikvm( 3877): Unable to open or create cache for &#x2F;data&#x2F;data&#x2F;com.mjar.test&#x2F;cache&#x2F;app@data.apk (&#x2F;data&#x2F;dalvik-cache&#x2F;data@data@com.mjar.test@cache@app@data.apk@classes.dex)</span><br><span class="line">E&#x2F;appproc ( 3877): ERROR: could not find class &#39;cmd.Main&#39;</span><br><span class="line">E&#x2F;dalvikvm( 3877): JNI posting fatal error: Native registration unable to find class &#39;android&#x2F;debug&#x2F;JNITest&#39;; aborting...</span><br><span class="line">I&#x2F;dalvikvm( 3877): &quot;main&quot; prio&#x3D;5 tid&#x3D;1 NATIVE</span><br><span class="line">I&#x2F;dalvikvm( 3877):   | group&#x3D;&quot;main&quot; sCount&#x3D;0 dsCount&#x3D;0 obj&#x3D;0x415b7ca8 self&#x3D;0x6d455010</span><br><span class="line">I&#x2F;dalvikvm( 3877):   | sysTid&#x3D;3877 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1074467156</span><br><span class="line">I&#x2F;dalvikvm( 3877):   | state&#x3D;R schedstat&#x3D;( 0 0 0 ) utm&#x3D;19 stm&#x3D;13 core&#x3D;0</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #00  pc 0000132e  &#x2F;system&#x2F;lib&#x2F;libcorkscrew.so (unwind_backtrace_thread+29)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #01  pc 00060652  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmDumpNativeStack(DebugOutputTarget const*, int)+33)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #02  pc 00054640  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmDumpThreadEx(DebugOutputTarget const*, Thread*, bool)+395)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #03  pc 000546ae  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmDumpThread(Thread*, bool)+25)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #04  pc 000490c0  &#x2F;system&#x2F;lib&#x2F;libdvm.so</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #05  pc 00001fa8  &#x2F;system&#x2F;lib&#x2F;libnativehelper.so (jniRegisterNativeMethods+39)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #06  pc 0004cd22  &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #07  pc 0004d010  &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so (android::AndroidRuntime::startReg(_JNIEnv*)+23)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #08  pc 0004da60  &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so (android::AndroidRuntime::start(char const*, char const*)+183)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #09  pc 0000105a  &#x2F;system&#x2F;bin&#x2F;app_process</span><br><span class="line">I&#x2F;dalvikvm( 3877):   #10  pc 0000e348  &#x2F;system&#x2F;lib&#x2F;libc.so (__libc_init+47)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   at dalvik.system.NativeStart.main(Native Method)</span><br><span class="line">I&#x2F;dalvikvm( 3877):   at dalvik.system.NativeStart.main(Native Method)</span><br><span class="line">I&#x2F;dalvikvm( 3877): </span><br><span class="line">E&#x2F;dalvikvm( 3877): VM aborting</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过分析日志得知崩溃的原因是因为cmd.Main这个类没找到，但是明明在5.0以上的版本是可以执行的所以可以排除类不在dex文件里，正当百思不得其姐的时候定睛一看还有一行很关键的信息  <code>E/dalvikvm( 3877): Dex cache directory isn&#39;t writable: /data/dalvik-cache</code>  看样子跟这个有点关系啊！我们知道在android上加载dex文件时系统会做一些优化以加快运行速度也就是dex2oat的过程优化后的odex文件就存储在<code>/data/dalvik-cache</code>这个目录中，因为我们加载自定义的dex文件所以在执行dex2oat的这个操作也是以普通应用的uid去执行的所以理所当然的会没有权限写入这个目录，但是不写入这个目录dex文件不就无法运行起来到这似乎陷入了一个僵局，没办法只能翻翻系统源码看看有没有什么可操作的空间了。</p>
<ul>
<li>我这里以Android4.2.2的源码抓重要的说 感兴趣的同学可以完整的跟一下app_process启动进程的整个流程</li>
</ul>
<p>经过app_process一系列的初始化最终会调到<a href="http://androidxref.com/4.2.2_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java">DexFile.java</a>去加载原始的dex文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class DexFile&#123;</span><br><span class="line"></span><br><span class="line">    public DexFile(File file) throws IOException &#123;</span><br><span class="line">        this(file.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DexFile(String fileName) throws IOException &#123;</span><br><span class="line">        mCookie &#x3D; openDexFile(fileName, null, 0);</span><br><span class="line">        mFileName &#x3D; fileName;</span><br><span class="line">        guard.open(&quot;close&quot;);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Open a DEX file.  The value returned is a magic VM cookie.  On</span><br><span class="line">     * failure, an IOException is thrown.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    native private static int openDexFile(String sourceName, String outputName,int flags, throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过DexFile的构造器调用最终会调到openDexFile这个native函数，这个native函数实现位于<a href="http://androidxref.com/4.2.2_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp#519">dalvik_system_DexFile.cpp</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const DalvikNativeMethod dvm_dalvik_system_DexFile[] &#x3D; &#123;</span><br><span class="line">    &#123; &quot;openDexFile&quot;,        &quot;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;I)I&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_openDexFile &#125;,</span><br><span class="line">    &#123; &quot;openDexFile&quot;,        &quot;([B)I&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_openDexFile_bytearray &#125;,</span><br><span class="line">    &#123; &quot;closeDexFile&quot;,       &quot;(I)V&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_closeDexFile &#125;,</span><br><span class="line">    &#123; &quot;defineClass&quot;,        &quot;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;ClassLoader;I)Ljava&#x2F;lang&#x2F;Class;&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_defineClass &#125;,</span><br><span class="line">    &#123; &quot;getClassNameList&quot;,   &quot;(I)[Ljava&#x2F;lang&#x2F;String;&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_getClassNameList &#125;,</span><br><span class="line">    &#123; &quot;isDexOptNeeded&quot;,     &quot;(Ljava&#x2F;lang&#x2F;String;)Z&quot;,</span><br><span class="line">        Dalvik_dalvik_system_DexFile_isDexOptNeeded &#125;,</span><br><span class="line">    &#123; NULL, NULL, NULL &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到openDexFile这个函数在jni层对应的是Dalvik_dalvik_system_DexFile_openDexFile函数这个函数中其中有一段很关键的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">     * Try to open it directly as a DEX if the name ends with &quot;.dex&quot;.</span><br><span class="line">     * If that fails (or isn&#39;t tried in the first place), try it as a</span><br><span class="line">     * Zip with a &quot;classes.dex&quot; inside.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (hasDexExtension(sourceName)</span><br><span class="line">            &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName);</span><br><span class="line"></span><br><span class="line">        pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">        pDexOrJar-&gt;isDex &#x3D; true;</span><br><span class="line">        pDexOrJar-&gt;pRawDexFile &#x3D; pRawDexFile;</span><br><span class="line">        pDexOrJar-&gt;pDexMemory &#x3D; NULL;</span><br><span class="line">    &#125; else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ALOGV(&quot;Opening DEX file &#39;%s&#39; (Jar)&quot;, sourceName);</span><br><span class="line"></span><br><span class="line">        pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">        pDexOrJar-&gt;isDex &#x3D; false;</span><br><span class="line">        pDexOrJar-&gt;pJarFile &#x3D; pJarFile;</span><br><span class="line">        pDexOrJar-&gt;pDexMemory &#x3D; NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGV(&quot;Unable to open DEX file &#39;%s&#39;&quot;, sourceName);</span><br><span class="line">        dvmThrowIOException(&quot;unable to open DEX file&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的注释还是写的比较详细的如果是dex文件后缀的则直接打开同时odex文件会直接写到<code>/data/dalvik-cache</code>这个目录中，这个也是直接导致我们通过app_process运行dex文件会崩溃的元凶，别着急我们继续往下看下面还有一个处理jar/zip/apk后缀的分支这个里面会不会有什么惊喜呢？跟到<code>dvmJarFileOpen</code>里面可以看到有这么一句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    int dvmJarFileOpen(const char* fileName, const char* odexOutputName,</span><br><span class="line">    JarFile** ppJarFile, bool isBootstrap)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line"></span><br><span class="line">    &#x2F;* First, look for a &quot;.odex&quot; alongside the jar file.  It will</span><br><span class="line">     * have the same name&#x2F;path except for the extension.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fd &#x3D; openAlternateSuffix(fileName, &quot;odex&quot;, O_RDONLY, &amp;cachedName);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里的注释我想大家应该的都明白了，对于apk文件处理方式有些特殊会优先在同级目录查找odex文件，所以我需要做的仅仅是把dex文件改为apk文件然后通过反射调用<a href="http://androidxref.com/4.2.2_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#139">DexFile#loadDex函数</a>指定第二个参数odex文件名称提前把odex文件生成出来再使用app_process去运行apk文件就可以了，不过为什么在Android5.0以上可以直接加载dex文件呢，于是我在8.0系统上又试了一下发现在运行dex文件的同时系统会自动在同级目录创建一个oat目录里面存放的正是odex文件，所以由此可以猜测当在高版本的系统上运行app_process命令如果没有权限写入<code>/data/dalvik-cache</code>则会在同级目录自动创建odex文件，这只是我个人的猜想并没有详细的研究源码怎么实现的感兴趣的话可以自己研究一下。</p>
]]></content>
      <categories>
        <category>Android疑难杂症</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>编程中的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>ByteBuffer详解</title>
    <url>/2020/11/11/ByteBuffer%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>之前对NIO开发不熟悉导致对ByteBuffer一直是一知半解的状态正好看到知乎上有个朋友写的不错于是转载过来</p>
<p>转自:<a href="https://zhuanlan.zhihu.com/p/56876443">https://zhuanlan.zhihu.com/p/56876443</a></p>
</blockquote>
<h2 id="在Java-nio中，主要有三大组件：Buffer，Channel和Selector。这三者之间的关系可以按照如下方式进行理解："><a href="#在Java-nio中，主要有三大组件：Buffer，Channel和Selector。这三者之间的关系可以按照如下方式进行理解：" class="headerlink" title="在Java nio中，主要有三大组件：Buffer，Channel和Selector。这三者之间的关系可以按照如下方式进行理解："></a>在Java nio中，主要有三大组件：Buffer，Channel和Selector。这三者之间的关系可以按照如下方式进行理解：</h2><ul>
<li>Buffer提供了一个字节缓冲区，其可以不断的从Channel中读取接收到的数据。Buffer的优点主要在于其提供了一系列的Api，能够让用户更方便的对数据进行读取和写入；</li>
<li>Channel简单来说就是一个信道，也就是客户端与服务器的一个连接，而且每个客户端都会对应一个Channel对象；</li>
<li>Selector是Java nio能够支持高并发数据处理一个关键，其核心理念就是IO多路复用的原理，简单的说就是当多个客户端（Channel）连接服务器时，可以通过Selector同时对这些客户端请求进行监听，当客户端发送数据到服务器之后由Selector对这些Channel进行分发处理。</li>
</ul>
<p>本文首先讲解ByteBuffer的实现原理，然后会介绍ByteBuffer中常用的Api，以及其在使用过程中需要注意的点。</p>
<ol>
<li><p><strong>实现原理</strong><br>对于ByteBuffer，其主要有五个属性：mark，position，limit，capacity和array。这五个属性的作用如下：</p>
<ul>
<li>mark：记录了当前所标记的索引下标；</li>
<li>position：对于写入模式，表示当前可写入数据的下标，对于读取模式，表示接下来可以读取的数据的下标；</li>
<li>limit：对于写入模式，表示当前可以写入的数组大小，默认为数组的最大长度，对于读取模式，表示当前最多可以读取的数据的位置下标；</li>
<li>capacity：表示当前数组的容量大小；</li>
<li>array：保存了当前写入的数据。</li>
</ul>
<p>这几个数据中，除了array是用于保存数据的以外，这里最终的主要是position，limit和capacity三个属性，因为对于写入和读取模式，这三个属性的表示的含义大不一样。</p>
<span id="more"></span></li>
<li><p>1 <strong>写入模式</strong><br> 如下图所示为初始状态和写入3个字节之后position，limit和capacity三个属性的状态：</p>
<p> <img src="https://pic3.zhimg.com/80/v2-7c322e5d80e7ff2300d037c5b8b3f9de_720w.jpg"></p>
<p> 从图中可以看出，在写入模式下，limit指向的始终是当前可最多写入的数组索引下标，position指向的则是下一个可以写入的数据的索引位置，而capacity则始终不会变化，即为数组大小。</p>
<p> 1.2 <strong>读取模式</strong></p>
<p> 假设我们按照上述方式在初始长度为6的ByteBuffer中写入了三个字节的数据，此时我们将模式切换为读取模式，那么这里的position，limit和capacity则变为如下形式：</p>
<p> <img src="https://pic4.zhimg.com/80/v2-30b16959027ab4dbbc8252557e22c717_720w.jpg"></p>
<p> 可以看到，当切换为读取模式之后，limit则指向了最后一个可读取数据的下一个位置，表示最多可读取的数据；position则指向了数组的初始位置，表示下一个可读取的数据的位置；capacity还是表示数组的最大容量。这里当我们一个一个读取数据的时候，position就会依次往下切换，当期与limit重合时，就表示当前ByteBuffer中已没有可读取的数据了。</p>
</li>
<li><p><strong>使用实例</strong></p>
<p>对于ByteBuffer的基本使用方式，从上面的演示中就可以看出，其主要有初始化，写入，切换和读取几个基本操作。如下是ByteBuffer的一个基本使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferApp</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个大小为6的ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">    print(buffer);  <span class="comment">// 初始状态：position: 0, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往buffer中写入3个字节的数据</span></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">    print(buffer);  <span class="comment">// 写入之后的状态：position: 3, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;************** after flip **************&quot;</span>);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    print(buffer);  <span class="comment">// 切换为读取模式之后的状态：position: 0, limit: 3, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.get();</span><br><span class="line">    buffer.get();</span><br><span class="line">    print(buffer);  <span class="comment">// 读取两个数据之后的状态：position: 2, limit: 3, capacity: 6</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;position: %d, limit: %d, capacity: %d\n&quot;</span>,</span><br><span class="line">      buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先创建一个最大容量为6的ByteBuffer，此时position为0，即初始状态，而limit为6，与最大容量一致。当我们往buffer中写入三个字节数据之后，此时的position为3，limit还是6，表示还可以继续往buffer中写入三个数据。当我们切换为读取模式之后，需要注意，此时buffer中写入了三个字节的数据，也就是说只有三个字节的数据可供读取，因而切换为读取模式之后，position指向了0，表示下一个可供读取的数据位置，而limit为3，即为之前写入的数据数量，而capacity始终为6，表示buffer的最大大小。</p>
<p>2.1 <strong>相关api</strong></p>
<ul>
<li><p>mark()<br>在前面我们讲过，ByteBuffer中海油一个mark属性，这个属性是一个标识的作用，即记录当前position的位置，在后续如果调用reset()或者flip()方法时，ByteBuffer的position就会被重置到mark所记录的位置。因而对于写入模式，在mark()并reset()后，将会回到mark记录的可以写入数据的位置；对于读取模式，在mark()并reset()后，将会回到mark记录的可以读取的数据的位置。如下是mark()方法分别演示写入和读取数据的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferApp</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// position: 0, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// position: 3, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.mark();  <span class="comment">// 写入三个字节数据后进行标记</span></span><br><span class="line">    <span class="comment">// position: 3, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">4</span>); <span class="comment">// 再次写入一个字节数据</span></span><br><span class="line">    <span class="comment">// position: 4, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.reset(); <span class="comment">// 对buffer进行重置，此时将恢复到Mark时的状态</span></span><br><span class="line">    <span class="comment">// position: 3, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();  <span class="comment">// 切换为读取模式，此时有三个数据可供读取</span></span><br><span class="line">    <span class="comment">// position: 0, limit: 3, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.get(); <span class="comment">// 读取一个字节数据之后进行标记</span></span><br><span class="line">    buffer.mark();</span><br><span class="line">    <span class="comment">// position: 1, limit: 3, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.get(); <span class="comment">// 继续读取一个字节数据</span></span><br><span class="line">    <span class="comment">// position: 2, limit: 3, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.reset(); <span class="comment">// 进行重置之后，将会恢复到mark的状态</span></span><br><span class="line">    <span class="comment">// position: 1, limit: 3, capacity: 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>rewind()<br>对于rewind()方法，它的主要作用在于将当前的position重置为0，并且mark重置为-1，而且无论mark是否进行过标记。很明显，rewind()和reset()方法都是进行重置的，但是reset()方法则是会优先重置到mark标记的位置。同理，对于写入模式，rewind()方法会重置为初始写入状态，对于读取模式，rewind()则会重置为初始读取模式，其不会对limit属性有任何影响。如下是rewind()方法的一个使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferApp</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// position: 0, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// position: 3, limit: 6, capacity: 6</span></span><br><span class="line"></span><br><span class="line">    buffer.rewind();  <span class="comment">// 调用rewind()方法之后，buffer状态将会重置</span></span><br><span class="line">    <span class="comment">// position: 0, limit: 6, capacity: 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>compact()<br>对于compact()方法，其主要作用在于在读取模式下进行数据压缩，并且方便下一步继续写入数据。比如在一个长度为6的ByteBuffer中写满了数据，然后在读取模式下读取了三个数据之后，我们想继续往buffer中写入数据，此时由于只有前三个字节是可用的，而后三个字节是有效的数据，此时如果写入的话是会把后面三个有效字节给覆盖掉的。因而需要将后面三个有效字节往前移动，以空出三个字节，并且将position指向下一个可供写入的位置，而不是迁移之后的索引0处。compact()方法的作用即在于此，如下是该方法的一个使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferApp</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">4</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">6</span>); <span class="comment">// 初始化一个写满的buffer</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// position: 0, limit: 6, capacity: 6  -- 切换为读取模式</span></span><br><span class="line"></span><br><span class="line">    buffer.get();</span><br><span class="line">    buffer.get();</span><br><span class="line">    <span class="comment">// position: 2, limit: 6, capacity: 6  -- 读取两个字节后，还剩余四个字节</span></span><br><span class="line"></span><br><span class="line">    buffer.compact();</span><br><span class="line">    <span class="comment">// position: 4, limit: 6, capacity: 6  -- 进行压缩之后将从第五个字节开始</span></span><br><span class="line"></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// position: 5, limit: 6, capacity: 6  -- 写入一个字节数据的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>小结</strong><br>本文首先展示了ByteBuffer在写入模式和读取模式下内部的一个状态，然后简单讲解了ByteBuffer的使用方式，并且展示了ByteBuffer各个常用Api的作用和用法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android开发实战</category>
      </categories>
      <tags>
        <tag>编程中的问题</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>InputStream无法与BufferReader同时用</title>
    <url>/2020/11/05/InputStream%E6%97%A0%E6%B3%95%E4%B8%8EBufferReader%E5%90%8C%E6%97%B6%E7%94%A8/</url>
    <content><![CDATA[<p>​    前两天客户端这边有一块业务一开始想的是用<code>socket</code>直接跟后端传数据,后来后端觉得基于目前的框架改太麻烦于是协商了一下还是改为HTTP协议,我一想HTTP传过来过我把HTTP的头给忽略掉不就可以了于是直接动手撸了个HTTP服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">BufferedReader r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">LinkedHashMap&lt;String, String&gt; headerFields = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String header; (header = r.readLine()) != <span class="keyword">null</span> &amp;&amp; !header.isEmpty();)&#123;</span><br><span class="line">    <span class="comment">//解析HTTP头</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(header)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = Integer.parseInt(headerFields.get(<span class="string">&quot;Content-Length&quot;</span>));</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">socket.getInputStream().read(buffer);</span><br><span class="line"><span class="comment">//处理业务数据</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">out.write(<span class="string">&quot;fuck you\r\n&quot;</span>).getBytes());</span><br><span class="line">out.flush();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>3分钟撸好信心满满的点了Run按钮,前面HTTP头正确读取出来但是到了<code>socket.getInputStream().read(buffer);</code> 这行就会卡主很奇怪看来看去一脸懵逼反复检查发送的数据和数据长度都没问题,过了很久才怀疑到<code>BufferedReader</code>头上于是跟了一下代码发现这厮会读取超过一行的长度导致之后用原始的<code>InputStream</code>读的时候会超过发送的数据长度导致卡住(其实是在等待客户端发送),后来解析头直接选择一个字节一个字节的读这样就没有问题了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read header</span></span><br><span class="line">LinkedHashMap&lt;String, String&gt; headerFields = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b; (b = in.read()) != -<span class="number">1</span>; )</span><br><span class="line">&#123;</span><br><span class="line">    baos.write(b);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//解析HTTP头</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read body</span></span><br><span class="line"><span class="keyword">if</span>(!headerFields.containsKey(<span class="string">&quot;Content-Length&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;request header not specify body length!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[Integer.parseInt(headerFields.get(<span class="string">&quot;Content-Length&quot;</span>))];</span><br><span class="line"><span class="keyword">int</span> len = in.read(buffer);</span><br><span class="line"><span class="comment">//处理业务数据</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">out.write(<span class="string">&quot;fuck you\r\n&quot;</span>).getBytes());</span><br><span class="line">out.flush();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发中趟过的大坑</category>
      </categories>
      <tags>
        <tag>编程中的问题</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript回调函数this指向问题</title>
    <url>/2021/03/01/TypeScript%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在使用<code>TypeScript</code>开发<code>frida hook</code>时遇到一个问题,当把一个类的函数传给另一个方法作为回调函数时,<code>this</code>指针指向的不是原始类的示例,经过一番搜索发现有很多人也碰到同样的问题所以在此记录一下:<br>出问题的代码:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SetIntervalTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> someNumber: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="built_in">this</span>.setIntervalCallback, <span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">setIntervalCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.someNumber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>改成这样就可以了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> setIntervalCallback = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.someNumber);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为只是为了临时解决业务问题所以暂不深究日后有空再来研究研究</p>
<blockquote>
<p>相关链接:<a href="https://github.com/microsoft/TypeScript/issues/10285">https://github.com/microsoft/TypeScript/issues/10285</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发中趟过的大坑</category>
      </categories>
      <tags>
        <tag>编程中的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed为何对京东无法生效</title>
    <url>/2020/11/06/Xposed%E4%B8%BA%E4%BD%95%E5%AF%B9%E4%BA%AC%E4%B8%9C%E6%97%A0%E6%B3%95%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>  前一阵子对京东的一个功能比较好奇于是就有了逆向京东的想法,我熟练的拿起了<code>jadx</code>对京东进行反编译居然没有混淆心中狂喜很快就找到入口点,于是又祭出了<code>Xposed</code>大法飞快的写了个插件Hook了<code>Activity</code>的<code>onCreate</code>方法,我迫不及待的跑了起来结果hook貌似没有生效任何Log都没有输出,反复检查后仍不得其解不过此时的我已心中暗暗猜测京东应该有一些反<code>Xposed</code>的机制,因为之前曾见过”酷安”和”知乎”也有这样的功能,于是又Hook了像<code>Class.forName </code>和<code>ClassLoader.loadClass</code>这样的函数来验证一下我的想法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(ClassLoader.class, <span class="string">&quot;loadClass&quot;</span>, String.class, <span class="keyword">new</span> XC_MethodHook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(((String)param.args[<span class="number">0</span>]).startsWith(<span class="string">&quot;de.robv.android.xposed&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">		Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;loadclass:&quot;</span> + Arrays.toString(param.args), <span class="keyword">new</span> Throwable());</span><br><span class="line">		param.setThrowable(<span class="keyword">new</span> ClassNotFoundException());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">XposedHelpers.findAndHookMethod(Class.class, <span class="string">&quot;forName&quot;</span>, String.class, <span class="keyword">new</span> XC_MethodHook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(((String)param.args[<span class="number">0</span>]).startsWith(<span class="string">&quot;de.robv.android.xposed&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">		Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;forName:&quot;</span> + Arrays.toString(param.args), <span class="keyword">new</span> Throwable());</span><br><span class="line">		param.setThrowable(<span class="keyword">new</span> ClassNotFoundException());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这是抓到的log:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-11-06 19:54:14.503 30297-30297/? D/Kaisar: loadclass:[de.robv.android.xposed.XposedBridge]</span><br><span class="line">    java.lang.Throwable</span><br><span class="line">        at com.kaisar.jdplugin.MainPlugin$1.beforeHookedMethod(MainPlugin.java:38)</span><br><span class="line">        at de.robv.android.xposed.XC_MethodHook.callBeforeHookedMethod(XC_MethodHook.java:51)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.HookStubManager.hookBridge(HookStubManager.java:281)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.MethodHookerStubs32.stub_hook_5(MethodHookerStubs32.java:228)</span><br><span class="line">        at java.lang.Runtime.nativeLoad(Native Method)</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:1014)</span><br><span class="line">        at java.lang.System.loadLibrary(System.java:1669)</span><br><span class="line">        at com.jingdong.app.mall.JDApp.loadLib(JDApp.java:134)</span><br><span class="line">        at com.jingdong.app.mall.JDApp.&lt;clinit&gt;(Unknown Source:0)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance0(Native Method)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance(Constructor.java:343)</span><br><span class="line">        at com.jd.chappie.loader.ChappieApplication.reflectClientApplication(Unknown Source:23)</span><br><span class="line">        at com.jd.chappie.loader.ChappieApplication.attachBaseContext(Unknown Source:3)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.swift.sandhook.SandHook.callOriginMethod(SandHook.java:185)</span><br><span class="line">        at com.swift.sandhook.SandHook.callOriginMethod(SandHook.java:163)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.HookStubManager.hookBridge(HookStubManager.java:304)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.MethodHookerStubs32.stub_hook_6(MethodHookerStubs32.java:234)</span><br><span class="line">        at android.app.Application.attach(Application.java:212)</span><br><span class="line">        at android.app.Instrumentation.newApplication(Instrumentation.java:1122)</span><br><span class="line">        at android.app.LoadedApk.makeApplication(LoadedApk.java:1052)</span><br><span class="line">        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5877)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.swift.sandhook.SandHook.callOriginMethod(SandHook.java:185)</span><br><span class="line">        at com.swift.sandhook.SandHook.callOriginMethod(SandHook.java:163)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.HookStubManager.hookBridge(HookStubManager.java:304)</span><br><span class="line">        at com.swift.sandhook.xposedcompat.hookstub.MethodHookerStubs32.stub_hook_0(MethodHookerStubs32.java:198)</span><br><span class="line">        at android.app.ActivityThread.access$1100(ActivityThread.java:200)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1660)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:193)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6762)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)</span><br></pre></td></tr></table></figure>



<p>天网恢恢疏而不漏,结果还真的发现在京东一个<code>so</code>中加载了<code>XposedBridge</code>这个类,京东再怎么说也是购物支付软件反<code>Xposed</code>这点技术肯定还是要做的,没关系既然<code>Xposed</code> hook不了的东西那就自己动手hook一下吧,于是在<code>Application</code>的<code>attachBaseContext</code>方法之前手动Hook了<code>ActivityThread</code>的<code>mH</code>变量中的一些关键函数并且输出一些log</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;com.jd.chappie.loader.ChappieApplication&quot;</span>, lpparam.classLoader, <span class="string">&quot;attachBaseContext&quot;</span>, Context.class, <span class="keyword">new</span> XC_MethodHook()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;attachBaseContext before:&quot;</span> + getClass().getName());</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class&lt;?&gt; ActivityThread = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">            Object currentActivityThread = ActivityThread.getMethod(<span class="string">&quot;currentActivityThread&quot;</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">            Field mH = ActivityThread.getDeclaredField(<span class="string">&quot;mH&quot;</span>);</span><br><span class="line">            mH.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Handler handler = (Handler)mH.get(currentActivityThread);</span><br><span class="line">            Field mCallback = Handler.class.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>);</span><br><span class="line">            mCallback.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            mCallback.set(handler, <span class="keyword">new</span> Handler.Callback()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;handler:&quot;</span> + msg);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;hook handler failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;attachBaseContext after:&quot;</span> + getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>不过奇怪的事情发生了hook还是没有发生任何作用,按道理来说不通过<code>Xposed</code> hook, 京东是不太容易知道hook了哪些函数,但是竟然没有任何log输出很奇怪,于是我又在<code>attachBaseContext</code>之前启动了一个线程延迟十秒以确保<code>attchBaseContext</code>流程走完检查hook点并输出日志但是更奇怪的是线程延迟了10秒竟还是没有任何输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;attachBaseContext before:&quot;</span> + getClass().getName());</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; ActivityThread = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">        Object currentActivityThread = ActivityThread.getMethod(<span class="string">&quot;currentActivityThread&quot;</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">        Field mH = ActivityThread.getDeclaredField(<span class="string">&quot;mH&quot;</span>);</span><br><span class="line">        mH.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Handler handler = (Handler)mH.get(currentActivityThread);</span><br><span class="line">        Field mCallback = Handler.class.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>);</span><br><span class="line">        mCallback.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        mCallback.set(handler, <span class="keyword">new</span> Handler.Callback()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;handler:&quot;</span> + msg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;hook handler ok&quot;</span>);</span><br><span class="line">        Object o = mCallback.get(handler);</span><br><span class="line">        Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;check handler:&quot;</span> + mCallback.get(handler));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;wait delay check handle&quot;</span>);</span><br><span class="line">                    SystemClock.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;delay check handler:&quot;</span> + mCallback.get(handler));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Throwable e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;delay check failed&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Kaisar&quot;</span>, <span class="string">&quot;hook handler failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难道说京东竟然可以检测到我开了线程并把我的线程给停掉了? 事情好像没有那么简单了 于是上<code>Xposed</code>开发群里问问大佬看看有没有遇到过结果还真有!</p>
<p>大佬说:<strong>狗东把log给吃了…</strong>  (划重点此题必考) 于是我把打log的地方换成了写文件 果然log有了 WTF 就这么简单? 这你敢信? 我以为用了什么宇宙无敌黑科技 结果就这搞了我几个小时?   卒…</p>
]]></content>
      <categories>
        <category>Xposed模块开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>编程中的问题</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>不通过文件转储直接从adb shell读取stdout数据</title>
    <url>/2020/08/04/%E4%B8%8D%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%BD%AC%E5%82%A8%E7%9B%B4%E6%8E%A5%E4%BB%8Eadb-shell%E8%AF%BB%E5%8F%96stdout%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>通常我们从Android设备中捕获当前UI界面信息使用以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell uiautomator dump &#x2F;sdcard&#x2F;screen.xml</span><br><span class="line">adb pull &#x2F;sdcard&#x2F;screen.xml</span><br></pre></td></tr></table></figure>
<p>在上面的代码块中我们经历了两个步骤</p>
<ol>
<li><p>执行命令结果输出到<code>/sdcard/screen.xml</code></p>
</li>
<li><p>拉取设备上的文件</p>
</li>
</ol>
<p>从效率上来看是很慢的那有没有比较快的办法呢? 答案是有的!<br>我们可以利用<code>/dev/tty</code>设备让它直接输出到<code>stdout</code>上这样就省去文件转储了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell uiautomator dump /dev/tty</span><br></pre></td></tr></table></figure>
<p>你满怀期待着等着结果只看到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UI hierchary dumped to: /dev/tty</span><br></pre></td></tr></table></figure>
<p>WTF? 这是什么鬼dump出来的信息去哪了?眉头一紧事情好像貌似没有这么简单…<br>经过一番研究发现我们使用的<code>adb shell</code>会将命令输出发给<code>pty</code>经过一顿骚操作<code>pty</code>把数据搞丢了,所以在新版的<code>adb</code>中引入了一个新的功能<code>exec-out</code>该参数可以将二进制数据直接原封不动的输出。详情请参考<a href="https://android.googlesource.com/platform/system/core/+/5d9d434efadf1c535c7fea634d5306e18c68ef1f"></a></p>
<p>所以只需要将命令改成这样即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb exec-out uiautomator dump &#x2F;dev&#x2F;tty</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android小技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用openstf部署一套内部测试平台</title>
    <url>/2020/10/29/%E4%BD%BF%E7%94%A8openstf%E9%83%A8%E7%BD%B2%E4%B8%80%E5%A5%97%E5%86%85%E9%83%A8%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul>
<li>Ubuntu20.04</li>
<li>Docker 19.03.13 #务必从<a href="https://docs.docker.com/engine/install/ubuntu/">官方</a>渠道安装否则用自带可能会遇到莫名其妙的问题<ul>
<li><a href="https://registry.hub.docker.com/_/rethinkdb">rethinkdb</a></li>
<li><a href="https://registry.hub.docker.com/r/sorccu/adb">sorccu/adb</a></li>
<li><a href="https://registry.hub.docker.com/r/devicefarmer/stf">devicefarmer/stf</a> 镜像(该版本为开发活跃的分叉)</li>
</ul>
</li>
</ul>
<h2 id="安装openstf"><a href="#安装openstf" class="headerlink" title="安装openstf"></a>安装openstf</h2><ol>
<li><code>sudo docker pull rethinkdb:latest</code> # 拉取rethinkdb 镜像</li>
<li><code>sudo docker pull sorccu/adb:latest </code># 拉取android adb 镜像</li>
<li><code>sudo docker pull devicefarmer/stf:latest</code> #拉取openstf 镜像</li>
</ol>
<h2 id="部署openstf"><a href="#部署openstf" class="headerlink" title="部署openstf"></a>部署openstf</h2><p>openstf部署方式有两种</p>
<ol>
<li>集中管理: openstf管理平台所连接的设备在一台机器上</li>
</ol>
<p><img src="https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgIEFbT3BlblNURi3mnLrlmahBXSAtLT4gQihEZXZpY2UpXG4gICBBW09wZW5TVEYt5py65ZmoQV0gLS0-IEMoRGV2aWNlKVxuICAgQVtPcGVuU1RGLeacuuWZqEFdIC0tPiBEKERldmljZSlcbiAgIEFbT3BlblNURi3mnLrlmahBXSAtLT4gRShEZXZpY2UpXG4gICBBW09wZW5TVEYt5py65ZmoQV0gLS0-IEYoRGV2aWNlKVxuICAgQVtPcGVuU1RGLeacuuWZqEFdIC0tPiBIKC4uLikiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCIsInRoZW1lVmFyaWFibGVzIjp7ImJhY2tncm91bmQiOiJ3aGl0ZSIsInByaW1hcnlDb2xvciI6IiNFQ0VDRkYiLCJzZWNvbmRhcnlDb2xvciI6IiNmZmZmZGUiLCJ0ZXJ0aWFyeUNvbG9yIjoiaHNsKDgwLCAxMDAlLCA5Ni4yNzQ1MDk4MDM5JSkiLCJwcmltYXJ5Qm9yZGVyQ29sb3IiOiJoc2woMjQwLCA2MCUsIDg2LjI3NDUwOTgwMzklKSIsInNlY29uZGFyeUJvcmRlckNvbG9yIjoiaHNsKDYwLCA2MCUsIDgzLjUyOTQxMTc2NDclKSIsInRlcnRpYXJ5Qm9yZGVyQ29sb3IiOiJoc2woODAsIDYwJSwgODYuMjc0NTA5ODAzOSUpIiwicHJpbWFyeVRleHRDb2xvciI6IiMxMzEzMDAiLCJzZWNvbmRhcnlUZXh0Q29sb3IiOiIjMDAwMDIxIiwidGVydGlhcnlUZXh0Q29sb3IiOiJyZ2IoOS41MDAwMDAwMDAxLCA5LjUwMDAwMDAwMDEsIDkuNTAwMDAwMDAwMSkiLCJsaW5lQ29sb3IiOiIjMzMzMzMzIiwidGV4dENvbG9yIjoiIzMzMyIsIm1haW5Ca2ciOiIjRUNFQ0ZGIiwic2Vjb25kQmtnIjoiI2ZmZmZkZSIsImJvcmRlcjEiOiIjOTM3MERCIiwiYm9yZGVyMiI6IiNhYWFhMzMiLCJhcnJvd2hlYWRDb2xvciI6IiMzMzMzMzMiLCJmb250RmFtaWx5IjoiXCJ0cmVidWNoZXQgbXNcIiwgdmVyZGFuYSwgYXJpYWwiLCJmb250U2l6ZSI6IjE2cHgiLCJsYWJlbEJhY2tncm91bmQiOiIjZThlOGU4Iiwibm9kZUJrZyI6IiNFQ0VDRkYiLCJub2RlQm9yZGVyIjoiIzkzNzBEQiIsImNsdXN0ZXJCa2ciOiIjZmZmZmRlIiwiY2x1c3RlckJvcmRlciI6IiNhYWFhMzMiLCJkZWZhdWx0TGlua0NvbG9yIjoiIzMzMzMzMyIsInRpdGxlQ29sb3IiOiIjMzMzIiwiZWRnZUxhYmVsQmFja2dyb3VuZCI6IiNlOGU4ZTgiLCJhY3RvckJvcmRlciI6ImhzbCgyNTkuNjI2MTY4MjI0MywgNTkuNzc2NTM2MzEyOCUsIDg3LjkwMTk2MDc4NDMlKSIsImFjdG9yQmtnIjoiI0VDRUNGRiIsImFjdG9yVGV4dENvbG9yIjoiYmxhY2siLCJhY3RvckxpbmVDb2xvciI6ImdyZXkiLCJzaWduYWxDb2xvciI6IiMzMzMiLCJzaWduYWxUZXh0Q29sb3IiOiIjMzMzIiwibGFiZWxCb3hCa2dDb2xvciI6IiNFQ0VDRkYiLCJsYWJlbEJveEJvcmRlckNvbG9yIjoiaHNsKDI1OS42MjYxNjgyMjQzLCA1OS43NzY1MzYzMTI4JSwgODcuOTAxOTYwNzg0MyUpIiwibGFiZWxUZXh0Q29sb3IiOiJibGFjayIsImxvb3BUZXh0Q29sb3IiOiJibGFjayIsIm5vdGVCb3JkZXJDb2xvciI6IiNhYWFhMzMiLCJub3RlQmtnQ29sb3IiOiIjZmZmNWFkIiwibm90ZVRleHRDb2xvciI6ImJsYWNrIiwiYWN0aXZhdGlvbkJvcmRlckNvbG9yIjoiIzY2NiIsImFjdGl2YXRpb25Ca2dDb2xvciI6IiNmNGY0ZjQiLCJzZXF1ZW5jZU51bWJlckNvbG9yIjoid2hpdGUiLCJzZWN0aW9uQmtnQ29sb3IiOiJyZ2JhKDEwMiwgMTAyLCAyNTUsIDAuNDkpIiwiYWx0U2VjdGlvbkJrZ0NvbG9yIjoid2hpdGUiLCJzZWN0aW9uQmtnQ29sb3IyIjoiI2ZmZjQwMCIsInRhc2tCb3JkZXJDb2xvciI6IiM1MzRmYmMiLCJ0YXNrQmtnQ29sb3IiOiIjOGE5MGRkIiwidGFza1RleHRMaWdodENvbG9yIjoid2hpdGUiLCJ0YXNrVGV4dENvbG9yIjoid2hpdGUiLCJ0YXNrVGV4dERhcmtDb2xvciI6ImJsYWNrIiwidGFza1RleHRPdXRzaWRlQ29sb3IiOiJibGFjayIsInRhc2tUZXh0Q2xpY2thYmxlQ29sb3IiOiIjMDAzMTYzIiwiYWN0aXZlVGFza0JvcmRlckNvbG9yIjoiIzUzNGZiYyIsImFjdGl2ZVRhc2tCa2dDb2xvciI6IiNiZmM3ZmYiLCJncmlkQ29sb3IiOiJsaWdodGdyZXkiLCJkb25lVGFza0JrZ0NvbG9yIjoibGlnaHRncmV5IiwiZG9uZVRhc2tCb3JkZXJDb2xvciI6ImdyZXkiLCJjcml0Qm9yZGVyQ29sb3IiOiIjZmY4ODg4IiwiY3JpdEJrZ0NvbG9yIjoicmVkIiwidG9kYXlMaW5lQ29sb3IiOiJyZWQiLCJsYWJlbENvbG9yIjoiYmxhY2siLCJlcnJvckJrZ0NvbG9yIjoiIzU1MjIyMiIsImVycm9yVGV4dENvbG9yIjoiIzU1MjIyMiIsImNsYXNzVGV4dCI6IiMxMzEzMDAiLCJmaWxsVHlwZTAiOiIjRUNFQ0ZGIiwiZmlsbFR5cGUxIjoiI2ZmZmZkZSIsImZpbGxUeXBlMiI6ImhzbCgzMDQsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlMyI6ImhzbCgxMjQsIDEwMCUsIDkzLjUyOTQxMTc2NDclKSIsImZpbGxUeXBlNCI6ImhzbCgxNzYsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlNSI6ImhzbCgtNCwgMTAwJSwgOTMuNTI5NDExNzY0NyUpIiwiZmlsbFR5cGU2IjoiaHNsKDgsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlNyI6ImhzbCgxODgsIDEwMCUsIDkzLjUyOTQxMTc2NDclKSJ9fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0"></p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name rethinkdb -v /srv/rethinkdb:/data --net host rethinkdb rethinkdb --<span class="built_in">bind</span> all --cache-size 8192 --http-port 8090</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name adbd --privileged -v /dev/bus/usb:/dev/bus/usb --net host sorccu/adb:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name stf --net host devicefarmer/stf stf <span class="built_in">local</span> --public-ip <span class="variable">$&#123;你的ip&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点:简单快捷适合小规模部署</li>
<li>缺点:不够灵活且单台机器挂载能有限</li>
</ul>
<ol start="2">
<li>分布式管理: openstf提供了provider模式可以用来进行分布式部署</li>
</ol>
<p><img src="https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbkFbT3BlblNURi3mnLrlmahBXSAtLT4gQihQcm92aWRlciBOb2RlKVxuQihQcm92aWRlciBOb2RlLeacuuWZqEIpIC0tPiBCMShEZXZpY2UpXG5CKFByb3ZpZGVyIE5vZGUt5py65ZmoQikgLS0-IEIyKERldmljZSlcbkIoUHJvdmlkZXIgTm9kZS3mnLrlmahCKSAtLT4gQjMoLi4uKVxuQVtPcGVuU1RGLeacuuWZqEFdIC0tPiBDKFByb3ZpZGVyIE5vZGUpXG5DKFByb3ZpZGVyIE5vZGUt5py65ZmoQykgLS0-IEMxKERldmljZSlcbkMoUHJvdmlkZXIgTm9kZS3mnLrlmahDKSAtLT4gQzIoRGV2aWNlKVxuQyhQcm92aWRlciBOb2RlLeacuuWZqEMpIC0tPiBDMyguLi4pXG5BW09wZW5TVEYt5py65ZmoQV0gLS0-IEQoUHJvdmlkZXIgTm9kZSlcbkQoUHJvdmlkZXIgTm9kZS3mnLrlmahEKSAtLT4gRDEoRGV2aWNlKVxuRChQcm92aWRlciBOb2RlLeacuuWZqEQpIC0tPiBEMihEZXZpY2UpXG5EKFByb3ZpZGVyIE5vZGUt5py65ZmoRCkgLS0-IEQzKC4uLikiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCIsInRoZW1lVmFyaWFibGVzIjp7ImJhY2tncm91bmQiOiJ3aGl0ZSIsInByaW1hcnlDb2xvciI6IiNFQ0VDRkYiLCJzZWNvbmRhcnlDb2xvciI6IiNmZmZmZGUiLCJ0ZXJ0aWFyeUNvbG9yIjoiaHNsKDgwLCAxMDAlLCA5Ni4yNzQ1MDk4MDM5JSkiLCJwcmltYXJ5Qm9yZGVyQ29sb3IiOiJoc2woMjQwLCA2MCUsIDg2LjI3NDUwOTgwMzklKSIsInNlY29uZGFyeUJvcmRlckNvbG9yIjoiaHNsKDYwLCA2MCUsIDgzLjUyOTQxMTc2NDclKSIsInRlcnRpYXJ5Qm9yZGVyQ29sb3IiOiJoc2woODAsIDYwJSwgODYuMjc0NTA5ODAzOSUpIiwicHJpbWFyeVRleHRDb2xvciI6IiMxMzEzMDAiLCJzZWNvbmRhcnlUZXh0Q29sb3IiOiIjMDAwMDIxIiwidGVydGlhcnlUZXh0Q29sb3IiOiJyZ2IoOS41MDAwMDAwMDAxLCA5LjUwMDAwMDAwMDEsIDkuNTAwMDAwMDAwMSkiLCJsaW5lQ29sb3IiOiIjMzMzMzMzIiwidGV4dENvbG9yIjoiIzMzMyIsIm1haW5Ca2ciOiIjRUNFQ0ZGIiwic2Vjb25kQmtnIjoiI2ZmZmZkZSIsImJvcmRlcjEiOiIjOTM3MERCIiwiYm9yZGVyMiI6IiNhYWFhMzMiLCJhcnJvd2hlYWRDb2xvciI6IiMzMzMzMzMiLCJmb250RmFtaWx5IjoiXCJ0cmVidWNoZXQgbXNcIiwgdmVyZGFuYSwgYXJpYWwiLCJmb250U2l6ZSI6IjE2cHgiLCJsYWJlbEJhY2tncm91bmQiOiIjZThlOGU4Iiwibm9kZUJrZyI6IiNFQ0VDRkYiLCJub2RlQm9yZGVyIjoiIzkzNzBEQiIsImNsdXN0ZXJCa2ciOiIjZmZmZmRlIiwiY2x1c3RlckJvcmRlciI6IiNhYWFhMzMiLCJkZWZhdWx0TGlua0NvbG9yIjoiIzMzMzMzMyIsInRpdGxlQ29sb3IiOiIjMzMzIiwiZWRnZUxhYmVsQmFja2dyb3VuZCI6IiNlOGU4ZTgiLCJhY3RvckJvcmRlciI6ImhzbCgyNTkuNjI2MTY4MjI0MywgNTkuNzc2NTM2MzEyOCUsIDg3LjkwMTk2MDc4NDMlKSIsImFjdG9yQmtnIjoiI0VDRUNGRiIsImFjdG9yVGV4dENvbG9yIjoiYmxhY2siLCJhY3RvckxpbmVDb2xvciI6ImdyZXkiLCJzaWduYWxDb2xvciI6IiMzMzMiLCJzaWduYWxUZXh0Q29sb3IiOiIjMzMzIiwibGFiZWxCb3hCa2dDb2xvciI6IiNFQ0VDRkYiLCJsYWJlbEJveEJvcmRlckNvbG9yIjoiaHNsKDI1OS42MjYxNjgyMjQzLCA1OS43NzY1MzYzMTI4JSwgODcuOTAxOTYwNzg0MyUpIiwibGFiZWxUZXh0Q29sb3IiOiJibGFjayIsImxvb3BUZXh0Q29sb3IiOiJibGFjayIsIm5vdGVCb3JkZXJDb2xvciI6IiNhYWFhMzMiLCJub3RlQmtnQ29sb3IiOiIjZmZmNWFkIiwibm90ZVRleHRDb2xvciI6ImJsYWNrIiwiYWN0aXZhdGlvbkJvcmRlckNvbG9yIjoiIzY2NiIsImFjdGl2YXRpb25Ca2dDb2xvciI6IiNmNGY0ZjQiLCJzZXF1ZW5jZU51bWJlckNvbG9yIjoid2hpdGUiLCJzZWN0aW9uQmtnQ29sb3IiOiJyZ2JhKDEwMiwgMTAyLCAyNTUsIDAuNDkpIiwiYWx0U2VjdGlvbkJrZ0NvbG9yIjoid2hpdGUiLCJzZWN0aW9uQmtnQ29sb3IyIjoiI2ZmZjQwMCIsInRhc2tCb3JkZXJDb2xvciI6IiM1MzRmYmMiLCJ0YXNrQmtnQ29sb3IiOiIjOGE5MGRkIiwidGFza1RleHRMaWdodENvbG9yIjoid2hpdGUiLCJ0YXNrVGV4dENvbG9yIjoid2hpdGUiLCJ0YXNrVGV4dERhcmtDb2xvciI6ImJsYWNrIiwidGFza1RleHRPdXRzaWRlQ29sb3IiOiJibGFjayIsInRhc2tUZXh0Q2xpY2thYmxlQ29sb3IiOiIjMDAzMTYzIiwiYWN0aXZlVGFza0JvcmRlckNvbG9yIjoiIzUzNGZiYyIsImFjdGl2ZVRhc2tCa2dDb2xvciI6IiNiZmM3ZmYiLCJncmlkQ29sb3IiOiJsaWdodGdyZXkiLCJkb25lVGFza0JrZ0NvbG9yIjoibGlnaHRncmV5IiwiZG9uZVRhc2tCb3JkZXJDb2xvciI6ImdyZXkiLCJjcml0Qm9yZGVyQ29sb3IiOiIjZmY4ODg4IiwiY3JpdEJrZ0NvbG9yIjoicmVkIiwidG9kYXlMaW5lQ29sb3IiOiJyZWQiLCJsYWJlbENvbG9yIjoiYmxhY2siLCJlcnJvckJrZ0NvbG9yIjoiIzU1MjIyMiIsImVycm9yVGV4dENvbG9yIjoiIzU1MjIyMiIsImNsYXNzVGV4dCI6IiMxMzEzMDAiLCJmaWxsVHlwZTAiOiIjRUNFQ0ZGIiwiZmlsbFR5cGUxIjoiI2ZmZmZkZSIsImZpbGxUeXBlMiI6ImhzbCgzMDQsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlMyI6ImhzbCgxMjQsIDEwMCUsIDkzLjUyOTQxMTc2NDclKSIsImZpbGxUeXBlNCI6ImhzbCgxNzYsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlNSI6ImhzbCgtNCwgMTAwJSwgOTMuNTI5NDExNzY0NyUpIiwiZmlsbFR5cGU2IjoiaHNsKDgsIDEwMCUsIDk2LjI3NDUwOTgwMzklKSIsImZpbGxUeXBlNyI6ImhzbCgxODgsIDEwMCUsIDkzLjUyOTQxMTc2NDclKSJ9fX0"></p>
<p>   需要准备两台机器A,B 在机器A上部署OpenSTF管理平台</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name rethinkdb -v /srv/rethinkdb:/data --net host rethinkdb rethinkdb --<span class="built_in">bind</span> all --cache-size 8192 --http-port 8090</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name adbd --privileged -v /dev/bus/usb:/dev/bus/usb --net host sorccu/adb:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name stf --net host devicefarmer/stf stf <span class="built_in">local</span> --public-ip <span class="variable">$&#123;你的ip&#125;</span> --bind-dev-pub=<span class="string">&quot;tcp://0.0.0.0:7114&quot;</span> --bind-dev-pull=<span class="string">&quot;tcp://0.0.0.0:7116&quot;</span> --allow-remote</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong>:</p>
</blockquote>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--bind-dev-pub=&quot;tcp://0.0.0.0:7114&quot; --bind-dev-pull=&quot;tcp://0.0.0.0:7116&quot;</span><br></pre></td></tr></table></figure>
<p><strong>这行一定要加否则服务将监听在127.0.0.1地址上会导致provider节点无法连接之前没加导致排查了很久</strong></p>
<p>在机器B上部署Provider节点</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name adbd --privileged -v /dev/bus/usb:/dev/bus/usb --net host sorccu/adb:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name stf --net host devicefarmer/stf stf provider --connect-sub tcp://<span class="variable">$&#123;机器A的IP&#125;</span>:7114 --connect-push tcp://<span class="variable">$&#123;机器A的IP&#125;</span>:7116 --public-ip <span class="variable">$&#123;机器A的IP&#125;</span> --storage-url http://<span class="variable">$&#123;机器A的IP&#125;</span>:7100/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点:灵活且理论支持无限拓展连接设备</li>
<li>缺点:配置略微复杂</li>
</ul>
<p>部署好后访问安装OpenSTF管理平台机器的ip地址加端口7100,如<a href="http://192.168.1.1:7100/">http://192.168.1.1:7100</a></p>
]]></content>
      <categories>
        <category>Android开发实战</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Android上通过pm命令安装拆分包</title>
    <url>/2019/11/26/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%8A%E9%80%9A%E8%BF%87pm%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E6%8B%86%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<ol>
<li>首先需要先调用<code>pm install-create -S [size]</code>创建一个install session 其中<code>[size]</code>是指所有拆分文件的总字节数，不过不加<code>-S [size]</code>貌似也是可以的，命令执行完会返回一个session id 这个session会在下面用到。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm install-create -S 28658294</span><br><span class="line">Success: created install session [1691973442]</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>写入拆分包<code>pm install-write -S [size] [session-id] [file-name] [file-path]</code> 如果有多个拆分包需要写入多次</li>
</ol>
<ul>
<li><code>[size]</code>单个拆分包文件的字节数</li>
<li><code>[session-id]</code> 调用<code>pm install-create -S [size]</code>所得到的session id</li>
<li><code>[file-name]</code> 拆分包文件名称保持原样就可以了</li>
<li><code>[file-path]</code> 需要写入拆分包文件路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm install-write -S 23728613 1691973442 base.apk &#x2F;data&#x2F;local&#x2F;tmp&#x2F;com.makemytrip&#x2F;base.apk</span><br><span class="line">pm install-write -S 2587864 1691973442 split_config.arm64_v8a.apk &#x2F;data&#x2F;local&#x2F;tmp&#x2F;com.makemytrip&#x2F;split_config.arm64_v8a.apk</span><br><span class="line">pm install-write -S 2341817 1691973442 split_config.hdpi.apk &#x2F;data&#x2F;local&#x2F;tmp&#x2F;com.makemytrip&#x2F;split_config.hdpi.apk</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>提交安装<code>pm install-commit [session-id]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm install-commit 1691973442</span><br></pre></td></tr></table></figure></li>
<li><p>取消安装<code>pm install-abandon [session-id]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm install-abandon 1691973442</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="或者可以使用下面的脚本自动安装"><a href="#或者可以使用下面的脚本自动安装" class="headerlink" title="或者可以使用下面的脚本自动安装"></a>或者可以使用下面的脚本自动安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"># get the total size in byte</span><br><span class="line">total&#x3D;0</span><br><span class="line">for apk in *.apk</span><br><span class="line">do</span><br><span class="line">    o&#x3D;( $(ls -l $apk) )</span><br><span class="line">    let total&#x3D;$total+$&#123;o[3]&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;pm install-create total size $total&quot;</span><br><span class="line"></span><br><span class="line">create&#x3D;$(pm install-create -S $total)</span><br><span class="line">sid&#x3D;$(echo $create |grep -E -o &#39;[0-9]+&#39;)</span><br><span class="line"></span><br><span class="line">echo &quot;pm install-create session id $sid&quot;</span><br><span class="line"></span><br><span class="line">for apk in *.apk</span><br><span class="line">do</span><br><span class="line">    _ls_out&#x3D;( $(ls -l $apk) )</span><br><span class="line">    echo &quot;write $apk to $sid&quot;</span><br><span class="line">    cat $apk | pm install-write -S $&#123;_ls_out[3]&#125; $sid $apk -</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">pm install-commit $sid</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android开发实战</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获得一个垂直的SeekBar</title>
    <url>/2020/11/13/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%9E%82%E7%9B%B4%E7%9A%84SeekBar/</url>
    <content><![CDATA[<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p>在开发”上帝模式”的一个新功能中偶然需要用到一个垂直的<code>SeekBar</code>,一开始想得比较简单系统应该有提供这样垂直的<code>SeekBar</code>但是翻了一下SDK并没有于是上网搜索,查找下来无非这两种:</p>
<ol>
<li>使用原生的<code>SeekBar</code>旋转90度</li>
<li>自定义<code>SeekBar</code>在<code>onDraw</code>方法和<code>onMeasure</code>方法中旋转画布并重新计算控件大小</li>
</ol>
<p>那为什么有两种呢让我们来分别分析一下这两个方案的优缺点:</p>
<ul>
<li><p>第一种使用原生的<code>SeekBar</code>最简单但是旋转后的宽高就不对了,实际上的宽是旋转后的高这也导致如果我们要增加<code>SeekBar</code>的高度就需要修改宽度但是会导致布局错乱以下是旋转前后对比:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;SeekBar</span><br><span class="line">           android:id=&quot;@+id/seekbar1&quot;</span><br><span class="line">           android:layout_width=&quot;120dp&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_gravity=&quot;center&quot;</span><br><span class="line">           android:clickable=&quot;true&quot;</span><br><span class="line">           android:layoutDirection=&quot;rtl&quot;/&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;SeekBar</span><br><span class="line">           android:id=&quot;@+id/seekbar2&quot;</span><br><span class="line">           android:layout_width=&quot;120dp&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_gravity=&quot;center&quot;</span><br><span class="line">           android:clickable=&quot;true&quot;</span><br><span class="line">           android:layoutDirection=&quot;rtl&quot;</span><br><span class="line">           android:rotation=&quot;90&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>

<p><img src="/2020/11/13/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%9E%82%E7%9B%B4%E7%9A%84SeekBar/rotate_compare.png"></p>
<p> 可以看到旋转后的<code>SeekBar</code>实际上控件位置并未改变,这会导致布局有问题, 因此有了第二种方案</p>
<ul>
<li><p>第二种自定义<code>SeekBar</code>这种方式就是为了解决第一种方式会导致控件实际布局大小不一致的情况,核心的逻辑也是旋转画布并且重新计算控件大小</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerticalSeekBar</span> <span class="keyword">extends</span> <span class="title">SeekBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VerticalSeekBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VerticalSeekBar</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VerticalSeekBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(h, w, oldh, oldw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(<span class="keyword">int</span> progress)</span>  <span class="comment">// it is necessary for calling setProgress on click of a button</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setProgress(progress);</span><br><span class="line">    onSizeChanged(getWidth(), getHeight(), <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(heightMeasureSpec, widthMeasureSpec);</span><br><span class="line">        setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">        c.rotate(-<span class="number">90</span>);</span><br><span class="line">        c.translate(-getHeight(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onDraw(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                setProgress(getMax() - (<span class="keyword">int</span>) (getMax() * event.getY() / getHeight()));</span><br><span class="line">                onSizeChanged(getWidth(), getHeight(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="/2020/11/13/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%9E%82%E7%9B%B4%E7%9A%84SeekBar/custom_seekbar.png"></p>
<p>  问题至此看起来已解决,不过我还是不想自定义<code>SeekBar</code>因为看起来比较麻烦但是有什么办法可以解决原生<code>SeekBar</code>大小的问题呢?此时我想起来系统的音量调节面板很好奇它是怎么实现的于是开始源码的探索之路</p>
<p> 我们要找到音量面板得先找到它的的代码因为平时调节音量这个窗口都是浮动在其他窗口上的因此可以断定是个悬浮窗,那我们先用<code>dumpsys</code>把<code>window</code>信息拿出来看一下</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell dumpsys window</span></span><br><span class="line">...</span><br><span class="line">WINDOW MANAGER ANIMATOR STATE (dumpsys window animator)</span><br><span class="line">    DisplayContentsAnimator #0:</span><br><span class="line">      Window #0: WindowStateAnimator&#123;6d30f com.android.systemui.ImageWallpaper&#125;</span><br><span class="line">      Window #1: WindowStateAnimator&#123;400acfc com.android.settings/com.android.settings.applications.InstalledAppDetails&#125;</span><br><span class="line">      Window #2: WindowStateAnimator&#123;fe69f85 com.android.chrome/com.google.android.apps.chrome.Main&#125;</span><br><span class="line">      Window #3: WindowStateAnimator&#123;8607f21 com.android.launcher3/com.android.a1launcher.AndroidOneLauncher&#125;</span><br><span class="line">      Window #4: WindowStateAnimator&#123;faaa1da com.android.launcher3/com.android.a1launcher.AndroidOneLauncher&#125;</span><br><span class="line">      Window #5: WindowStateAnimator&#123;193860b com.mjar.test/com.mjar.test.MainActivity&#125;</span><br><span class="line">      Window #6: WindowStateAnimator&#123;6299ce8 com.iapgame.ia2048/com.example.jrsen.testapp.MainActivity&#125;</span><br><span class="line">      Window #7: WindowStateAnimator&#123;f6af01 DockedStackDivider&#125;</span><br><span class="line">      Window #8: WindowStateAnimator&#123;e2101a6 AssistPreviewPanel&#125;</span><br><span class="line">      Window #9: WindowStateAnimator&#123;f2b29d2 StatusBar&#125;</span><br><span class="line">      Window #10: WindowStateAnimator&#123;ef277e7 VolumeDialogImpl&#125;</span><br><span class="line">      Window #11: WindowStateAnimator&#123;68afaa3 PointerLocation&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 可以看到有一个很可疑的窗口 <code>Window #10: WindowStateAnimator&#123;ef277e7 VolumeDialogImpl&#125;</code>名字看上去跟音量相关应该就是它没跑了,拿着这个名字到Android源码中搜索在<code>frameworks/base/packages/SystemUI/src/com/android/systemui/volume/VolumeDialogImpl.java</code> 中找到了它,跟了一下代码找到了加载布局的相关代码片段</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRow</span><span class="params">(<span class="keyword">final</span> VolumeRow row, <span class="keyword">final</span> <span class="keyword">int</span> stream, <span class="keyword">int</span> iconRes, <span class="keyword">int</span> iconMuteRes,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> important, <span class="keyword">boolean</span> defaultStream)</span> </span>&#123;</span><br><span class="line">    row.stream = stream;</span><br><span class="line">    row.iconRes = iconRes;</span><br><span class="line">    row.iconMuteRes = iconMuteRes;</span><br><span class="line">    row.important = important;</span><br><span class="line">    row.defaultStream = defaultStream;</span><br><span class="line">    row.view = mDialog.getLayoutInflater().inflate(R.layout.volume_dialog_row, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 找到<code>frameworks/base/packages/SystemUI/res/layout/volume_dialog_row.xml</code>对应的布局文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;FrameLayout</span><br><span class="line">             android:id=&quot;@+id/volume_row_slider_frame&quot;</span><br><span class="line">             android:layout_width=&quot;match_parent&quot;</span><br><span class="line">             android:layout_marginTop=&quot;@dimen/volume_dialog_slider_margin_top&quot;</span><br><span class="line">             android:layout_marginBottom=&quot;@dimen/volume_dialog_slider_margin_bottom&quot;</span><br><span class="line">             android:layoutDirection=&quot;rtl&quot;</span><br><span class="line">             android:layout_height=&quot;@dimen/volume_dialog_slider_height&quot;&gt;</span><br><span class="line">    &lt;SeekBar</span><br><span class="line">             android:id=&quot;@+id/volume_row_slider&quot;</span><br><span class="line">             android:clickable=&quot;true&quot;</span><br><span class="line">             android:layout_width=&quot;@dimen/volume_dialog_slider_height&quot;</span><br><span class="line">             android:layout_height=&quot;match_parent&quot;</span><br><span class="line">             android:layoutDirection=&quot;rtl&quot;</span><br><span class="line">             android:layout_gravity=&quot;center&quot;</span><br><span class="line">             android:rotation=&quot;90&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 到这里问题就找到答案了系统也是用的原生的<code>SeekBar</code>只不过在外层包裹了一个<code>FrameLayout</code>用于裁切<code>SeekBar</code>的实际大小,实在是秒啊!</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>求知若渴遇到不懂的多研究研究源码总能在里面找到惊喜</p>
]]></content>
      <categories>
        <category>Android开发实战</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何调试Xposed模块不用重启</title>
    <url>/2019/11/29/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95Xposed%E6%A8%A1%E5%9D%97%E4%B8%8D%E7%94%A8%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<blockquote>
<p>我想做过Xposed模块开发的一定对调试模块必须要重启手机这个机制不陌生， 拜这个机制所赐每次开发起来苦不堪言。稍微改点东西就需要重启手机少则几十秒要是碰到性能稍差一点的手机几分钟也是有可能的。那我们今天就来好好聊聊怎么才能让修改后的代码即时生效呢？首先要搞清楚这个问题还必须从为什么插件每次修改都要重启手机说起，我们可以通过<a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial">Xposed开发文档</a>了解到Xposed的工作方式是通过替换/system/bin/app_process这个二进制文件来实现的进程注入的,我们知道app_process是所有进程的启动入口所以xposed替换了这个文件修改了内部执行逻辑优先去加载我们的插件然后再去加载原始的App代码所以才得以实现各种hook，但是问题就出现在加载插件上了，默认的第一次加载插件时系统会在<code>/data/dalvik-cache/</code>创建一份字节码文件给需虚拟机执行，但是因为这个文件只会在第一次加载的时候创建所以当我们修改了插件后再安装这个文件是不会变的，这也就导致我们的改动不会立即生效需要重启手机让系统生成一个新的字节码文件，那肯定有小伙伴会想那我手动把这个字节码文件删了呢？很遗憾我在Android7.0上尝试了一下并未成功原因未知。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>好了既然我们知道问题产生的原因那我们就可以找到相应的解决办法，知己知彼百战不殆我们可以在Xposed加载我们插件代码的时候加一层代理用来动态找我们的插件代码位置这样就可以实现不用重启手机即时生效了当然如果仅hook应用了的话还需要强行停止一下应用以确保进程重新加载新代码，如果hook <code>system_server</code>进程了的话那还是需要重启手机的因为需要让<code>system_server</code>进程重新启动加载新的插件代码。</p>
</blockquote>
<blockquote>
<p>下面是完整的动态加载代码可以直接使用，仅在调试时使用请勿在发布版本中用!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开发更新模块无需重启 需要在xposed_init指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HotLoader</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = HotLoader.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends IXposedHookLoadPackage&gt; XPOSED_INIT_CLASS = MainPlugin.class;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Process.myUid() == Process.SYSTEM_UID)</span><br><span class="line">            &#123;</span><br><span class="line">                IXposedHookLoadPackage iXposedHookLoadPackage = XPOSED_INIT_CLASS.newInstance();</span><br><span class="line">                iXposedHookLoadPackage.handleLoadPackage(lpparam);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                PackageInfo packageInfo = getPackageInfo(BuildConfig.APPLICATION_ID, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;hot load dex path:&quot;</span> + packageInfo.applicationInfo.sourceDir + <span class="string">&quot; uid=&quot;</span> + Process.myUid());</span><br><span class="line">                PathClassLoader classLoader = <span class="keyword">new</span> PathClassLoader(packageInfo.applicationInfo.sourceDir, IXposedHookLoadPackage.class.getClassLoader());</span><br><span class="line">                IXposedHookLoadPackage iXposedHookLoadPackage = (IXposedHookLoadPackage)classLoader.loadClass(XPOSED_INIT_CLASS.getName()).newInstance();</span><br><span class="line">                iXposedHookLoadPackage.handleLoadPackage(lpparam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable t)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;loader exception&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageInfo <span class="title">getPackageInfo</span><span class="params">(String packageName, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;PrivateApi&quot;)</span> Class&lt;?&gt; ServiceManagerClass = Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">        IBinder binder = (IBinder)XposedHelpers.callStaticMethod(ServiceManagerClass, <span class="string">&quot;checkService&quot;</span>, <span class="string">&quot;package&quot;</span>);</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;PrivateApi&quot;)</span> Class&lt;?&gt; IPackageManager$StubClass = Class.forName(<span class="string">&quot;android.content.pm.IPackageManager$Stub&quot;</span>);</span><br><span class="line">        IInterface packageServiceManager = (IInterface)XposedHelpers.callStaticMethod(IPackageManager$StubClass, <span class="string">&quot;asInterface&quot;</span>, binder);</span><br><span class="line">        <span class="keyword">return</span> (PackageInfo)XposedHelpers.callMethod(packageServiceManager, <span class="string">&quot;getPackageInfo&quot;</span>, packageName, flags, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Xposed模块开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>如何远程调试一台Android设备</title>
    <url>/2020/05/21/%E5%A6%82%E4%BD%95%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%80%E5%8F%B0Android%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>要想跨越公网调试Android设备首先需要解决两个问题:</p>
<ol>
<li>如何让adb走tcp通信而不是走usb数据线</li>
<li>如何从公网连接这台设备</li>
</ol>
<h2 id="第一个问题-通过tcp调试Android手机"><a href="#第一个问题-通过tcp调试Android手机" class="headerlink" title="第一个问题:通过tcp调试Android手机"></a>第一个问题:通过tcp调试Android手机</h2><p>其实<code>adb</code>本身是支持通过tcp协议传输数据的只是可能大部分人从来没用过这个功能,大家可以在终端里面输入adb –help查看,里面有这么几个参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">networking:</span><br><span class="line"> connect HOST[:PORT]      connect to a device via TCP&#x2F;IP</span><br><span class="line"> disconnect [[HOST]:PORT] disconnect from given TCP&#x2F;IP device, or all</span><br><span class="line">...</span><br><span class="line"> usb                      restart adbd listening on USB</span><br><span class="line"> tcpip PORT               restart adbd listening on TCP on PORT</span><br></pre></td></tr></table></figure>

<p>connect和disconnect是用来连接一台远程设备或者断开远程设备的,usb和tcpip选项是用来切换手机端adbd守护进程工作模式的我们要用到的就是tcpip这个参数使adbd服务监听在一个特定的网络端口上</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig wlan0 #先查看一下手机wifi的ip地址后续连接的时候会用到</span><br><span class="line">adb tcpip 5555 #将手机切换到tcp模式并在5555端口上监听</span><br><span class="line">adb connect 192.168.1.8:5555 #连接手机对应的ip地址和端口</span><br></pre></td></tr></table></figure>

<p>至此第一个问题已解决</p>
<span id="more"></span>

<h2 id="第二个问题-跨越公网连接设备"><a href="#第二个问题-跨越公网连接设备" class="headerlink" title="第二个问题:跨越公网连接设备"></a>第二个问题:跨越公网连接设备</h2><p>在大多数的环境中我们手机都是通过连接一台无线路由器NAT上网的,但是熟悉网络的小伙伴一定知道路由器并不会给手机分配一个公网IP而是一个内网的,因此我们理论上从公网上是不能直接访问到这台手机的.这里我们需要做一个内网穿透把这台手机给暴露在公网上这样我们才能直接访问,而目前内网穿透的方案有很多像商业的<code>花生壳</code>以及开源的<code>nginx</code>或<code>frp</code>这些,商业的限制太多切收费而<code>nginx</code>又太复杂那剩下的只有<code>frp</code>了不了解<code>frp</code>的同学可以自行搜索一下使用起来也比较简单,不过这里又有一个问题了我们需要一台具有公网IP服务器来运行<code>frp</code>的server端!这…貌似又陷入了死循环… 不过幸好找到一个免费的<a href="https://www.natfrp.com/">frp服务器</a>用<a href="https://github.com/FrpcCluster/frpc-Android">Android版本的frp的客户端</a>可以直接连接并且速度还不错具体怎么配置查看frp文档很简单,感谢站长用爱发电! 至此需要的东西都准备齐了大致的网络拓扑如下</p>
<p><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQW5kcm9pZOiuvuWkhy0tPj5uYXRmcnDmnI3liqHlmag66YCa6L-HZnJwY-aYoOWwhDU1NTXnq6_lj6NcbiAgICBub3RlIG92ZXIgQW5kcm9pZOiuvuWkhzphZGJk55uR5ZCsNTU1Neerr-WPo1xuICAgIG5vdGUgb3ZlciBuYXRmcnDmnI3liqHlmag655uR5ZCseC54LngueDo1NTU1XG4gICAgUEPlvIDlj5HosIPor5XkuLvmnLotPj5uYXRmcnDmnI3liqHlmag6dGNwXG4gICAgbm90ZSBvdmVyIFBD5byA5Y-R6LCD6K-V5Li75py6OmFkYiBjb25uZWN0IHgueC54Lng6NTU1NVxuICAgIG5hdGZycOacjeWKoeWZqC0tPj5BbmRyb2lk6K6-5aSHOui9rOWPkWNvbm5lY3Tor7fmsYJcbiAgICAgICAgICAgICIsIm1lcm1haWQiOnt9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></p>
<ol>
<li><p>先把Android设备切换到tcp模式下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb tcpip 5555 #将手机切换到tcp模式并在5555端口上监听</span><br></pre></td></tr></table></figure></li>
<li><p>去natfrp网站注册账号申请一个隧道<br><img src="/2020/05/21/%E5%A6%82%E4%BD%95%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%80%E5%8F%B0Android%E8%AE%BE%E5%A4%87/step_1.png">创建好了之后点击配置文件这个选择之前申请的服务器节点下面就会限制对应的配置文件</p>
<p><img src="/2020/05/21/%E5%A6%82%E4%BD%95%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%80%E5%8F%B0Android%E8%AE%BE%E5%A4%87/step_2.png"></p>
</li>
<li><p>安装Android frpc客户端</p>
<ul>
<li><p>下载对应手机架构的<a href="https://github.com/fatedier/frp/releases">frpc客户端</a><br>arm架构下载<a href="https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_arm.tar.gz">frp_0.33.0_linux_arm.tar.gz</a><br>arm64架构下载<a href="https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_arm64.tar.gz">frp_0.33.0_linux_arm64.tar.gz</a></p>
</li>
<li><p>下载完成后从压缩文件中把<code>frpc</code>解压出来传到设备上的临时目录并追加执行权限</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push frpc &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">adb shell chmod +x &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frpc</span><br></pre></td></tr></table></figure></li>
<li><p>导入在网站上生成的客户端配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">cat &gt; /sdcard/frpc.ini &lt;&lt; EOL</span><br><span class="line">[common]</span><br><span class="line">server_addr = 27.155.87.89</span><br><span class="line">server_port = 7000</span><br><span class="line">tcp_mux = true</span><br><span class="line">pool_count = 1</span><br><span class="line">protocol = tcp</span><br><span class="line">user = xxxxxxxxxxxxxx</span><br><span class="line">token = xxxxxxxxxxxxxxxx</span><br><span class="line">dns_server = 114.114.114.114</span><br><span class="line"> </span><br><span class="line">[AndroidTunnel]</span><br><span class="line">privilege_mode = true</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5555</span><br><span class="line">remote_port = 58998</span><br><span class="line">use_encryption = false</span><br><span class="line">use_compression = true</span><br><span class="line">EOL</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>运行<code>frpc</code>客户端映射端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup /data/local/tmp/frpc -c /sdcard/frpc.ini &gt; /sdcard/frpc.log &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 执行完之后就可以把命令行窗口给关闭了</p>
</blockquote>
</li>
</ul>
</li>
<li><p>远程调试</p>
<p>找到客户端配置文件中的<code>server_addr</code>和<code>remote_port</code>字段这两个就是我们的连接设备的地址和端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect 27.155.87.89:58998</span><br></pre></td></tr></table></figure>

<p>如果不出意外的话应该就会连上的之后就可以像在本地一样调试设备了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android奇巧淫技</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>找回Ubuntu16.04中nautilus输入文字快速定位文件功能</title>
    <url>/2020/12/08/%E6%89%BE%E5%9B%9EUbuntu16.04%E4%B8%ADnautilus%E8%BE%93%E5%85%A5%E6%96%87%E5%AD%97%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在<code>16.04</code>的版本中<code>nautilus</code>文件管理器有一项快速定位文件的功能非常好用直接在文件夹中打出首字母即可快速定位到文件,但是在<code>18.04</code>以上的版本中默认就取消了这项功能使得我迁移到新版本中非常不适应今天碰巧找到了找回这个功能的办法记录一下:</p>
<ol>
<li><p>第一种安装第三方插件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:lubomir-brindza/nautilus-typeahead</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">nautilus -r</span><br></pre></td></tr></table></figure></li>
<li><p>第二种调整配置文件</p>
<p>2.1. 先安装<code>dconf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install dconf-editor</span><br></pre></td></tr></table></figure>

<p>2.2 打开<code>dconf-editor</code>找到<code>org -&gt; gnome -&gt; nautilus -&gt; preferences -&gt; enable-interactive-search </code>打钩即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>我的Linux生活</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>查看apk签名信息</title>
    <url>/2020/08/03/%E6%9F%A5%E7%9C%8Bapk%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -printcert -jarfile sample.apk</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>用 Golang 在 Android 上实现代理的几个问题</title>
    <url>/2020/04/23/%E7%94%A8-Golang-%E5%9C%A8-Android-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>转自:<a href="https://blog.dio.wtf/post/tips-for-golang-proxy-for-android/">https://blog.dio.wtf/post/tips-for-golang-proxy-for-android/</a> 仅供备份</p>
</blockquote>
<p>用 Golang 来实现的代理不要太多，像 <a href="https://github.com/v2ray/v2ray-core">V2Ray</a>，<a href="https://github.com/txthinking/brook">Brook</a>，<a href="https://github.com/Dreamacro/clash">Clash</a>。一方面得益于 Golang 标准库对于网络编程的支持，另一方面也是由于其便利的交叉编译。如果要在 Android 上用 Golang 实现一套代理方案，还是必须要处理一些问题，或者说是所有的代理方案都要解决的平台特性。</p>
<h2 id="IPC-传递文件描述符"><a href="#IPC-传递文件描述符" class="headerlink" title="IPC 传递文件描述符"></a>IPC 传递文件描述符</h2><p>Android 上使用 <a href="https://developer.android.com/reference/android/net/VpnService">VpnService</a> 由系统创建一个 TUN 虚拟网卡并接收所有的流量，API 会返回一个 file descriptor，通过这个 FD 可以读取/写入 IP packet。</p>
<p>为了稳定性和性能考虑，我们通常会将代理程序放到一个单独的进程里。但是在 Android 的阉割版 Linux 环境下，子进程是无法访问父进程的 FD。这里就需要用到 Linux 通用的进程间共享 FD 的方案，也就是给 Unix Socket 设置 <code>SCM_RIGHTS</code> 标识，然后用 <code>recvmsg</code> 和 <code>sendmsg</code> 来收发。在 Android 和 Golang 中都有对应的 API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> LocalSocket.setFileDescriptorsForSend (FileDescriptor[] fds)</span><br><span class="line"><span class="keyword">public</span> FileDescriptor[] LocalSocket.getAncillaryFileDescriptors ()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnixRights encodes file descriptors into a socket control message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span>.<span class="title">UnixRights</span><span class="params">(fds ...<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span>.<span class="title">Sendmsg</span><span class="params">(fd <span class="keyword">int</span>, p, oob []<span class="keyword">byte</span>, to Sockaddr, flags <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span>.<span class="title">Recvmsg</span><span class="params">(fd <span class="keyword">int</span>, p, oob []<span class="keyword">byte</span>, flags <span class="keyword">int</span>)</span> <span class="params">(n, oobn <span class="keyword">int</span>, recvflags <span class="keyword">int</span>, from Sockaddr, err error)</span></span></span><br><span class="line"><span class="comment">// ParseSocketControlMessage parses b as an array of socket control</span></span><br><span class="line"><span class="comment">// messages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span>.<span class="title">ParseSocketControlMessage</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">([]SocketControlMessage, error)</span></span></span><br><span class="line"><span class="comment">// ParseUnixRights decodes a socket control message that contains an</span></span><br><span class="line"><span class="comment">// integer array of open file descriptors from another process.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span>.<span class="title">ParseUnixRights</span><span class="params">(m *SocketControlMessage)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Socket-建连之前-protect-文件描述符"><a href="#Socket-建连之前-protect-文件描述符" class="headerlink" title="Socket 建连之前 protect 文件描述符"></a>Socket 建连之前 protect 文件描述符</h2><p>如果我们在创建 TUN 的时候（启动 VpnService ）设置的路由是 0.0.0.0/0 的情况下，所有的本地流量都会经过 TUN 设备，包括代理应用的数据包，这样就会进入一个死循环。这里需要用到 VpnService 的 <a href="https://developer.android.com/reference/android/net/VpnService#protect(int)">protect</a> 函数，这个函数接收一个 TCP/UDP 的 Socket 或者一个 FD。经过 protected 的 Socket 收发的数据包就不在经过 TUN 设备了。</p>
<p>Golang 的 net 库对网络做了很好的封装，比如创建一个TCP连接，使用 net.Dial 就可以拿到一个成功连接 net.Conn。但是在 Android 上，我们必须先拿到 Socket 的 FD 并调用 protect，否则 net.Dial 只会返回 error。</p>
<p>基于 V2Ray 实现的代理（<a href="https://github.com/xiaokangwang/AndroidLibV2ray/blob/master/VPN/vpnservice_support.go">AndroidLibV2ray</a>和 <a href="https://github.com/2dust/v2rayNG/blob/1.1.12/AndroidLibV2rayLite/VPN/vpnservice_support.go">v2rayNG</a>）通常是直接创建 unix.Socket 然后调用 unix.Connect 建立连接，再对外封装成 net.Dial 方法。</p>
<p>在 Go 1.11 里标准库给 net.Dial 添加了 <a href="https://golang.org/pkg/net/#Dialer.Control">Dialer.Control</a> 这个字段，相当于给 net.Dialer 注册了一个Socket创建之后、连接建立之前的回调，可以很方便的拿到 net.Dialer 的 FD。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d := &amp;net.Dialer&#123;&#125;</span><br><span class="line">d.Control = <span class="function"><span class="keyword">func</span><span class="params">(network, address <span class="keyword">string</span>, c syscall.RawConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.Control(<span class="function"><span class="keyword">func</span><span class="params">(fd <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Access socket fd</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>P.S. 这里也可以通过 <a href="https://developer.android.com/reference/android/net/VpnService.Builder.html#addDisallowedApplication(java.lang.String)">VpnService.Builder.addDisallowedApplication</a> 把代理应用排除在外，这样就不需要使用 protect 了🤣。可以参考最近刚刚开源的 <a href="https://github.com/Kr328/ClashForAndroid/blob/24e1732091c1a5089858bfefc776fe229367b997/service/src/main/java/com/github/kr328/clash/service/TunService.kt#L149">ClashForAndroid</a></p>
<h2 id="选择-Gomobile-还是编译成-Exectuable-Binary"><a href="#选择-Gomobile-还是编译成-Exectuable-Binary" class="headerlink" title="选择 Gomobile 还是编译成 Exectuable Binary"></a>选择 Gomobile 还是编译成 Exectuable Binary</h2><p>Golang 官方实现了 <a href="https://github.com/golang/mobile">Gomobile</a> 用于编译移动端可用的 Golang 程序。在 Android 平台上编译的是包含 JNI interface 的 AAR 文件，可以直接从 Java 调用 Golang 代码。所以这种情况下通常将 Gomobile 和 VpnService 运行在同一个进程中，这样的话就不需要上面提到的 IPC 的工作了。这样实现的项目有 <a href="https://github.com/2dust/v2rayNG">V2RayNG</a> 和 <a href="https://github.com/eycorsican/kitsunebi-android">kitsunebi-android</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App-&gt;VpnService: AIDL</span><br><span class="line">note over App:Main Process</span><br><span class="line">VpnService--&gt;Gomobile:JNI</span><br><span class="line">note over VpnService:VPN Process</span><br><span class="line">Gomobile--&gt;VpnService:JNI</span><br><span class="line">note over Gomobile:VPN Process</span><br><span class="line">VpnService-&gt;App:AIDL</span><br></pre></td></tr></table></figure>


<p>另一种做法是将 Golang 编译成可执行的二进制文件，然后通过 <code>ProcessBuilder</code> 或者 <code>Runtime.exec</code> 运行在独立进程里，需要 Unix Socket 进行进程间通讯。因为 ShadowSocks-Android 就是这样的实现的，所以也算是一个比较稳定主流的方案，这样实现的项目有 <a href="https://github.com/Kr328/ClashForAndroid">ClashForAndroid</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App-&gt;VpnService:AIDL</span><br><span class="line">note over App:Main Process</span><br><span class="line">VpnService-&gt;Binary:Unix Socket</span><br><span class="line">note over VpnService:VPN Process</span><br><span class="line">Binary-&gt;VpnService:Unix Socket</span><br><span class="line">note over Binary:Isolate Process</span><br><span class="line">VpnService-&gt;App:AIDL</span><br></pre></td></tr></table></figure>

<p>目前来看两种方案都可以很好的工作在 Android 上，Gomobile 的优点就是 Java-&gt;Golang 调用比较方便，编译简单，但是相对的 Golang-&gt;Java 只能通过实现接口，另外包体积较大。具体选哪种就见仁见智了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://fqrouter.tumblr.com/post/51474945203/socks%E4%BB%A3%E7%90%86%E8%BD%ACvpn">socks代理转VPN</a></p>
]]></content>
      <categories>
        <category>Android开发实战</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>编程中的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Android Studio missing essential plugin org.jetbrains.android</title>
    <url>/2020/11/20/%E8%A7%A3%E5%86%B3Android-Studio-missing-essential-plugin-org-jetbrains-android/</url>
    <content><![CDATA[<p>最近把Android Studio升级到了<code>4.1.1</code>版本之前安装了一个<code>smailidea</code>的插件老是报不兼容于是强迫症的我手贱了一下把插件给禁用了,禁用的时候没注意把依赖的一些东西也给禁用了于是报了下面的错误</p>
<p><img src="/2020/11/20/%E8%A7%A3%E5%86%B3Android-Studio-missing-essential-plugin-org-jetbrains-android/picture_02.png"></p>
<p>这是禁用插件时候的依赖提示</p>
<p><img src="/2020/11/20/%E8%A7%A3%E5%86%B3Android-Studio-missing-essential-plugin-org-jetbrains-android/picture_01.png"></p>
<p>可以看见其实把很多核心的组件都给禁用了那怎么办呢?难不成真的要按提示上说的要重装Android Studio?不要慌问题不大其实还有一种办法就是把被禁用的插件恢复就可以了,大家可以把Android Studio的配置目录的<code>disabled_plugins.txt</code>这个文件删除这样Android Studio就可以正常启动了, 这个文件每个系统存放的位置不太一样一般都在下面这几个目录 如果不在可以在主目录全局搜索一下这个文件</p>
<p>Windows: <code>C:\Users\%USERNAME%\AndroidStudio4.1\config</code></p>
<p>Linux: <code>~/.config/Google/AndroidStudio4.1</code></p>
<p>MacOS: <code>~/Library/Application Support/Google/AndroidStudio4.1</code></p>
]]></content>
      <categories>
        <category>Android疑难杂症</category>
      </categories>
      <tags>
        <tag>编程中的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>解决gradle无法同步的问题</title>
    <url>/2021/01/14/%E8%A7%A3%E5%86%B3gradle%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not install Gradle distribution from &#39;http:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-6.5-bin.zip&#39;.</span><br></pre></td></tr></table></figure>

<p>就在刚刚为了观摩一下<code>libgdx</code>引擎创建了一个工程虽然挂了梯子但是死活同步不了 不用说了肯定还是我们的万里长城防火墙搞的鬼了,感谢方校长让我们离西方的”邪恶势力”又远了一步!</p>
<p>好了 不吐槽了解决办法也很简单打开项目下的<code>gradle/wrapper/gradle-wrapper.properties</code>文件将下载地址改为<code>https</code>就好了</p>
]]></content>
      <categories>
        <category>Android疑难杂症</category>
      </categories>
      <tags>
        <tag>编程中的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>零成本让你拥有Mac触摸板鼠标</title>
    <url>/2020/04/30/%E9%9B%B6%E6%88%90%E6%9C%AC%E8%AE%A9%E4%BD%A0%E6%8B%A5%E6%9C%89Mac%E8%A7%A6%E6%91%B8%E6%9D%BF%E9%BC%A0%E6%A0%87/</url>
    <content><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>相信用过Mac触摸板鼠标的都被它的丝滑流畅给惊艳过,但是作为一个IT穷屌丝怎么买得起那样高大上的玩意,不过前几天玩<code>VNC</code>的时候倒是有一个很意外发现用起来简直跟Mac鼠标有得一拼.</p>
<h2 id="你需要的东西"><a href="#你需要的东西" class="headerlink" title="你需要的东西"></a>你需要的东西</h2><ul>
<li><p>手机一台<code>Android</code>/<code>IOS</code>都可以</p>
</li>
<li><p><code>RealVNC</code><a href="http://play.google.com/store/apps/details?id=com.realvnc.viewer.android">Android</a>/<a href="https://apps.apple.com/us/app/vnc-viewer/id352019548">IOS</a></p>
</li>
</ul>
<h2 id="我该怎么用"><a href="#我该怎么用" class="headerlink" title="我该怎么用"></a>我该怎么用</h2><p>原理很简单就是在电脑上开启vnc server不同操作系统开启方式不一样像Mac和Ubuntu这样本身就是支持VNC的直接在系统设置中打开屏幕共享即可而Windows用户稍微麻烦一些需要额外安装一个<a href="https://www.tightvnc.com/download.php">tightvnc</a>软件安装过程比较简单在此不讨论自行研究,这样我们直接从手机端通过VNC连过去一个触摸板鼠标就做好了,主要是RealVNC这个软件操作起来比较流畅下面我介绍一下这个软件基本的操作用法:</p>
<ol>
<li><code>鼠标左击</code> 直接点击一下屏幕</li>
<li><code>鼠标右击</code> 双指点击一下屏幕</li>
<li><code>滚动网页</code> 双指上下搓屏幕</li>
<li><code>鼠标选择文字</code> 双击屏幕拖动选择</li>
<li><code>鼠标粘贴问题</code> 三指点击屏幕</li>
</ol>
<p>其他的骚操作可以查看RealVNC的帮助信息</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>至此你已经拥有一个流畅的触摸板鼠标了,当然相比于Mac的触摸板鼠标还差很远但是已经有了几分的样子,用手机当触摸板想想也是蛮炫酷的当然有个不好的地方就是手机的画面是和电脑同步的要是有个黑屏只支持操作的模式就好了.</p>
]]></content>
      <categories>
        <category>Android奇巧淫技</category>
      </categories>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
</search>
